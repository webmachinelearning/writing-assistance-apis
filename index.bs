<pre class="metadata">
Title: Writing Assistance APIs
Shortname: writing-assistance
Level: None
Status: CG-DRAFT
Group: webml
Repository: webmachinelearning/writing-assistance-apis
URL: https://webmachinelearning.github.io/writing-assistance-apis
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: The summarizer, writer, and rewriter APIs provide high-level interfaces to call on a browser or operating system's built-in language model to help with writing tasks.
Markup Shorthands: markdown yes, css no
Complain About: accidental-2119 yes, missing-example-ids yes
Assume Explicit For: yes
Default Biblio Status: current
Boilerplate: omit conformance
Indent: 2
Die On: warning
</pre>

<pre class="anchors">
urlPrefix: https://tc39.es/ecma402/; spec: ECMA-402
  type: dfn
    text: [[AvailableLocales]]; url: sec-internal-slots
    text: Unicode canonicalized locale identifier; url: sec-language-tags
  type: abstract-op
    text: LookupMatchingLocaleByBestFit; url: sec-lookupmatchinglocalebybestfit
    text: IsStructurallyValidLanguageTag; url: sec-isstructurallyvalidlanguagetag
    text: CanonicalizeUnicodeLocaleId; url: sec-canonicalizeunicodelocaleid
urlPrefix: https://tc39.es/ecma262/; spec: ECMA-262
  type: abstract-op
    text: floor; url: eqn-floor
  type: dfn
    text: current realm; url: current-realm
urlPrefix: https://whatpr.org/webidl/1465.html; spec: WEBIDL
  type: interface
    text: QuotaExceededError; url: quotaexceedederror
  type: dfn; for: QuotaExceededError
    text: requested; url: quotaexceedederror-requested
    text: quota; url: quotaexceedederror-quota
</pre>

<style>
dl.props { display: grid; grid-template-columns: max-content auto; row-gap: 0.25em; column-gap: 1em; }
dl.props > dt { grid-column-start: 1; margin: 0; }
dl.props > dd { grid-column-start: 2; margin: 0; }
p + dl.props { margin-top: -0.5em; }

.enum-table tbody th { white-space: nowrap; }
</style>

<h2 id="intro">Introduction</h2>

For now, see the [explainer](https://github.com/webmachinelearning/writing-assistance-apis/blob/main/README.md).

<h2 id="shared-apis">Shared APIs</h2>

<xmp class="idl">
[Exposed=(Window,Worker), SecureContext]
interface CreateMonitor : EventTarget {
  attribute EventHandler ondownloadprogress;
};

callback CreateMonitorCallback = undefined (CreateMonitor monitor);

enum Availability {
  "unavailable",
  "downloadable",
  "downloading",
  "available"
};

interface mixin DestroyableModel {
  undefined destroy();
};
</xmp>

<hr>

The following are the [=event handlers=] (and their corresponding [=event handler event types=]) that must be supported, as [=event handler IDL attributes=], by all {{CreateMonitor}} objects:

<table>
  <thead>
    <tr>
      <th>[=Event handler=]
      <th>[=Event handler event type=]
  <tbody>
    <tr>
      <td><dfn attribute for="CreateMonitor">ondownloadprogress</dfn>
      <td><dfn event for="CreateMonitor">downloadprogress</dfn>
</table>

<hr>

Every [=interface=] [=interface/including=] the {{DestroyableModel}} interface mixin has a <dfn export for="DestroyableModel">destruction abort controller</dfn>, an {{AbortController}}, set by the [=initialize as a destroyable=] algorithm.

<p class="note">The [=DestroyableModel/destruction abort controller=] is only used internally, as a way of tracking calls to {{DestroyableModel/destroy()}}. Since it is easy to combine multiple {{AbortSignal}}s using [=create a dependent abort signal=], this lets us centralize handling of any {{AbortSignal}} the web developer provides to specific method calls, with any calls to {{DestroyableModel/destroy()}}.

<div algorithm>
  To <dfn>initialize as a destroyable</dfn> an {{DestroyableModel}} object |destroyable|:

  1. Let |controller| be a [=new=] {{AbortController}} created in |destroyable|'s [=relevant realm=].

  1. Set |controller|'s [=AbortController/signal=] to a [=new=] {{AbortSignal}} created in |destroyable|'s [=relevant realm=].

  1. Set |destroyable|'s [=DestroyableModel/destruction abort controller=] to |controller|.
</div>

<div algorithm>
  <p>The <dfn method for="DestroyableModel">destroy()</dfn> method steps are to [=DestroyableModel/destroy=] [=this=] given a new "{{AbortError}}" {{DOMException}}.
</div>

<div algorithm>
  To <dfn for="DestroyableModel">destroy</dfn> an {{DestroyableModel}} |destroyable|, given a JavaScript value |reason|:

  1. [=AbortController/Signal abort=] given |destroyable|'s [=DestroyableModel/destruction abort controller=] and |reason|.

  1. The user agent should release any resources associated with |destroyable|, such as AI models loaded to support its operation, as long as those resources are not needed for other ongoing operations.
</div>


<h2 id="summarizer-api">The summarizer API</h2>

<xmp class="idl">
[Exposed=(Window,Worker), SecureContext]
interface Summarizer {
  static Promise<Summarizer> create(optional SummarizerCreateOptions options = {});
  static Promise<Availability> availability(optional SummarizerCreateCoreOptions options = {});

  Promise<DOMString> summarize(
    DOMString input,
    optional SummarizerSummarizeOptions options = {}
  );
  ReadableStream summarizeStreaming(
    DOMString input,
    optional SummarizerSummarizeOptions options = {}
  );

  readonly attribute DOMString sharedContext;
  readonly attribute SummarizerType type;
  readonly attribute SummarizerFormat format;
  readonly attribute SummarizerLength length;

  readonly attribute FrozenArray<DOMString>? expectedInputLanguages;
  readonly attribute FrozenArray<DOMString>? expectedContextLanguages;
  readonly attribute DOMString? outputLanguage;

  Promise<double> measureInputUsage(
    DOMString input,
    optional SummarizerSummarizeOptions options = {}
  );
  readonly attribute unrestricted double inputQuota;
};
Summarizer includes DestroyableModel;

dictionary SummarizerCreateCoreOptions {
  SummarizerType type = "key-points";
  SummarizerFormat format = "markdown";
  SummarizerLength length = "short";

  sequence<DOMString> expectedInputLanguages;
  sequence<DOMString> expectedContextLanguages;
  DOMString outputLanguage;
};

dictionary SummarizerCreateOptions : SummarizerCreateCoreOptions {
  AbortSignal signal;
  CreateMonitorCallback monitor;

  DOMString sharedContext;
};

dictionary SummarizerSummarizeOptions {
  AbortSignal signal;
  DOMString context;
};

enum SummarizerType { "tl;dr", "teaser", "key-points", "headline" };
enum SummarizerFormat { "plain-text", "markdown" };
enum SummarizerLength { "short", "medium", "long" };
</xmp>

<h3 id="summarizer-creation">Creation</h3>

<div algorithm>
  The static <dfn method for="Summarizer">create(|options|)</dfn> method steps are:

  1. Return the result of [=creating an AI model object=] given |options|, [=validate and canonicalize summarizer options=], [=computing summarizer options availability=], [=download the summarization model=], [=initialize the summarization model=], and [=create a summarizer object=].
</div>

<div algorithm>
  To <dfn>validate and canonicalize summarizer options</dfn> given an {{SummarizerCreateCoreOptions}} |options|, perform the following steps. They mutate |options| in place to canonicalize and deduplicate language tags, and throw a {{TypeError}} if any are invalid.

  1. [=Validate and canonicalize language tags=] given |options| and "{{SummarizerCreateCoreOptions/expectedInputLanguages}}".

  1. [=Validate and canonicalize language tags=] given |options| and "{{SummarizerCreateCoreOptions/expectedContextLanguages}}".

  1. [=Validate and canonicalize language tags=] given |options| and "{{SummarizerCreateCoreOptions/outputLanguage}}".
</div>

<div algorithm>
  To <dfn>download the summarization model</dfn>, given an {{SummarizerCreateCoreOptions}} |options|:

  1. [=Assert=]: these steps are running [=in parallel=].

  1. Initiate the download process for everything the user agent needs to summarize text according to |options|. This could include a base AI model, fine-tunings for specific languages or option values, or other resources.

  1. If the download process cannot be started for any reason, then return false.

  1. Return true.
</div>

<div algorithm>
  To <dfn>initialize the summarization model</dfn>, given an {{SummarizerCreateOptions}} |options|:

  1. [=Assert=]: these steps are running [=in parallel=].

  1. Perform any necessary initialization operations for the AI model backing the user agent's summarization capabilities.

    This could include loading the model into memory, loading |options|["{{SummarizerCreateOptions/sharedContext}}"] into the model's context window, or loading any fine-tunings necessary to support the other options expressed by |options|.

  1. If initialization failed because the process of loading |options| resulted in using up all of the model's input quota, then:

    1. Let |requested| be the amount of input usage needed to encode |options|. The encoding of |options| as input is [=implementation-defined=].

      <p class="note" id="note-options-input-usage-encoding">This could be the amount of tokens needed to represent these options in a <a href="https://arxiv.org/abs/2404.08335">language model tokenization scheme</a>, possibly with prompt engineering. Or it could be 0, if the implementation plans to send the options to the underlying model with every [=summarize=] operation.

    1. Let |quota| be the maximum input quota that the user agent supports for encoding |options|.

    1. [=Assert=]: |requested| is greater than |quota|. (That is how we reached this error branch.)

    1. Return a [=quota exceeded error information=] whose [=QuotaExceededError/requested=] is |requested| and [=QuotaExceededError/quota=] is |quota|.

  1. If initialization failed for any other reason, then return a [=DOMException error information=] whose [=DOMException error information/name=] is "{{OperationError}}" and whose [=DOMException error information/details=] contain appropriate detail.

  1. Return null.
</div>

<div algorithm>
  To <dfn>create a summarizer object</dfn>, given a [=ECMAScript/realm=] |realm| and an {{SummarizerCreateOptions}} |options|:

  1. [=Assert=]: these steps are running on |realm|'s [=ECMAScript/surrounding agent=]'s [=agent/event loop=].

  1. Let |inputQuota| be the amount of input quota that is available to the user agent for future [=summarize|summarization=] operations. (This value is [=implementation-defined=], and may be +∞ if there are no specific limits beyond, e.g., the user's memory, or the limits of JavaScript strings.)

    <p class="note">For implementations that do not have infinite quota, this will generally vary for each {{Summarizer}} instance, depending on how much input quota was used by encoding |options|. See <a href="#note-options-input-usage-encoding">this note</a> on that encoding.

  1. Return a new {{Summarizer}} object, created in |realm|, with

    <dl class="props">
      : [=Summarizer/shared context=]
      :: |options|["{{SummarizerCreateOptions/sharedContext}}"] if it [=map/exists=]; otherwise null

      : [=Summarizer/summary type=]
      :: |options|["{{SummarizerCreateCoreOptions/type}}"]

      : [=Summarizer/summary format=]
      :: |options|["{{SummarizerCreateCoreOptions/format}}"]

      : [=Summarizer/summary length=]
      :: |options|["{{SummarizerCreateCoreOptions/length}}"]

      : [=Summarizer/expected input languages=]
      :: the result of [=creating a frozen array=] given |options|["{{SummarizerCreateCoreOptions/expectedInputLanguages}}"] if it [=set/is empty|is not empty=]; otherwise null

      : [=Summarizer/expected context languages=]
      :: the result of [=creating a frozen array=] given |options|["{{SummarizerCreateCoreOptions/expectedContextLanguages}}"] if it [=set/is empty|is not empty=]; otherwise null

      : [=Summarizer/output language=]
      :: |options|["{{SummarizerCreateCoreOptions/outputLanguage}}"] if it [=map/exists=]; otherwise null

      : [=Summarizer/input quota=]
      :: |inputQuota|
    </dl>
</div>

<h3 id="summarizer-availability">Availability</h3>

<div algorithm>
  The static <dfn method for="Summarizer">availability(|options|)</dfn> method steps are:

  1. Return the result of [=computing AI model availability=] given |options|, [=validate and canonicalize summarizer options=], and [=compute summarizer options availability=].
</div>

<div algorithm>
  To <dfn>compute summarizer options availability</dfn> given an {{SummarizerCreateCoreOptions}} |options|, perform the following steps. They return either an {{Availability}} value or null, and they mutate |options| in place to update language tags to their best-fit matches.

  1. [=Assert=]: this algorithm is running [=in parallel=].

  1. Let |availability| be the [=summarizer non-language options availability=] given |options|["{{SummarizerCreateCoreOptions/type}}"], |options|["{{SummarizerCreateCoreOptions/format}}"], and |options|["{{SummarizerCreateCoreOptions/length}}"].

  1. Let |languageAvailabilities| be the [=summarizer language availabilities=].

  1. If |languageAvailabilities| is null, then return null.

  1. Let |inputLanguageAvailability| be the result of [=computing summarizer language availability=] given |options|["{{SummarizerCreateCoreOptions/expectedInputLanguages}}"] and |languageAvailabilities|'s [=language availabilities/input languages=].

  1. Let |contextLanguagesAvailability| be the result of [=computing summarizer language availability=] given |options|["{{SummarizerCreateCoreOptions/expectedContextLanguages}}"] and |languageAvailabilities|'s [=language availabilities/context languages=].

  1. Let |outputLanguagesList| be « |options|["{{SummarizerCreateCoreOptions/outputLanguage}}"] ».

  1. Let |outputLanguageAvailability| be the result of [=computing summarizer language availability=] given |outputLanguagesList| and |languageAvailabilities|'s [=language availabilities/output languages=].

  1. Set |options|["{{SummarizerCreateCoreOptions/outputLanguage}}"] to |outputLanguagesList|[0].

  1. Return the [=Availability/minimum availability=] given « |availability|, |inputLanguageAvailability|, |contextLanguagesAvailability|, |outputLanguageAvailability| ».
</div>

<div algorithm>
  To <dfn>compute summarizer language availability</dfn> given an [=ordered set=] of strings |requestedLanguages| and a [=map=] from {{Availability}} values to [=sets=] of strings |availabilities|, perform the following steps. They return an {{Availability}} value, and they mutate |requestedLanguages| in place to update language tags to their best-fit matches.

  1. Let |availability| be "{{Availability/available}}".

  1. [=set/For each=] |language| of |requestedLanguages|:

    1. [=list/For each=] |availabilityToCheck| of « "{{Availability/available}}", "{{Availability/downloading}}", "{{Availability/downloadable}}" »:

      1. Let |languagesWithThisAvailability| be |availabilities|[|availabilityToCheck|].

      1. Let |bestMatch| be [$LookupMatchingLocaleByBestFit$](|languagesWithThisAvailability|, « |language| »).

      1. If |bestMatch| is not undefined, then:

        1. [=list/Replace=] |language| with |bestMatch|.\[[locale]] in |requestedLanguages|.

        1. Set |availability| to the [=Availability/minimum availability=] given |availability| and |availabilityToCheck|.

        1. [=iteration/Break=].

    1. Return "{{Availability/unavailable}}".

  1. Return |availability|.
</div>

<div algorithm>
  The <dfn>summarizer non-language options availability</dfn>, given a {{SummarizerType}} |type|, {{SummarizerFormat}} |format|, and an {{SummarizerLength}} |length|, is given by the following steps. They return an {{Availability}} value or null.

  1. [=Assert=]: this algorithm is running [=in parallel=].

  1. If there is some error attempting to determine whether the user agent supports summarizing text, which the user agent believes to be transient (such that re-querying the [=summarizer non-language options availability=] could stop producing such an error), then return null.

  1. If the user agent supports summarizing text into the type of summary described by |type|, in the format described by |format|, and with the length guidance given by |length| without performing any downloading operations, then return "{{Availability/available}}".

  1. If the user agent believes it can summarize text according to |type|, |format|, and |length|, but only after finishing a download (e.g., of an AI model or fine-tuning) that is already ongoing, then return "{{Availability/downloadable}}".

  1. If the user agent believes it can summarize text according to |type|, |format|, and |length|, but only after performing a download (e.g., of an AI model or fine-tuning), then return "{{Availability/downloadable}}".

  1. Otherwise, return "{{Availability/unavailable}}".
</div>

A <dfn>language availabilities</dfn> is a [=struct=] with the following [=struct/items=]:

* <dfn for="language availabilities">input languages</dfn>
* <dfn for="language availabilities">context languages</dfn>
* <dfn for="language availabilities">output languages</dfn>

All of these [=struct/items=] are [=maps=] from {{Availability}} values to [=sets=] of strings representing [=Unicode canonicalized locale identifiers=]. Their [=map/keys=] will always be one of "{{Availability/downloading}}", "{{Availability/downloadable}}", or "{{Availability/available}}" (i.e., they will never be "{{Availability/unavailable}}"). [[!ECMA-402]]

<div algorithm>
  The <dfn>summarizer language availabilities</dfn> are given by the following steps. They return a [=language availabilities=] or null.

  1. [=Assert=]: this algorithm is running [=in parallel=].

  1. If there is some error attempting to determine whether the user agent supports summarizing text, which the user agent believes to be transient (such that re-querying the [=summarizer language availabilities=] could stop producing such an error), then return null.

  1. Return a [=language availabilities=] with:

    <dl class="props">
      : [=language availabilities/input languages=]
      :: the result of [=getting language availabilities=] given the purpose of summarizing text written in that language

      : [=language availabilities/context languages=]
      :: the result of [=getting language availabilities=] given the purpose of summarizing text using web-developer provided context information written in that language

      : [=language availabilities/output languages=]
      :: the result of [=getting language availabilities=] given the purpose of producing text summaries in that language
    </dl>
</div>

<div class="example" id="example-subtags-chinese">
  A common setup seen in today's software is to support two types of written Chinese: "traditional Chinese" and "simplified Chinese". Let's suppose that the user agent supports summarizing text written in traditional Chinese with no downloads, and simplified Chinese after a download.

  One way this could be implemented would be for [=summarizer language availabilities=] to return that "`zh-Hant`" is in the [=language availabilities/input languages=]["{{Availability/available}}"] set, and "`zh`" and "`zh-Hans`" are in the [=language availabilities/input languages=]["{{Availability/downloadable}}"] set. This return value conforms to the requirements of the [=language tag set completeness rules=], in ensuring that "`zh`" is present. Per <a class="allow-2119" href="#language-tag-completeness-implementation-defined">the "should"-level guidance</a>, the implementation has determined that "`zh`" belongs in the set of downloadable input languages, with "`zh-Hans`", instead of in the set of available input languages, with "`zh-Hant`".

  Combined with the use of [$LookupMatchingLocaleByBestFit$], this means {{Summarizer/availability()}} will give the following answers:

  <xmp class="language-js">
  function a(languageTag) {
    return ai.summarizer.availability({
      expectedInputLanguages: [languageTag]
    });
  }

  await a("zh") === "downloadable";
  await a("zh-Hant") === "available";
  await a("zh-Hans") === "downloadable";

  await a("zh-TW") === "available";      // zh-TW will best-fit to zh-Hant
  await a("zh-HK") === "available";      // zh-HK will best-fit to zh-Hant
  await a("zh-CN") === "downloadable";   // zh-CN will best-fit to zh-Hans

  await a("zh-BR") === "downloadable";   // zh-BR will best-fit to zh
  await a("zh-Kana") === "downloadable"; // zh-Kana will best-fit to zh
  </xmp>
</div>

<h3 id="the-Summarizer-class">The {{Summarizer}} class</h3>

Every {{Summarizer}} has a <dfn for="Summarizer">shared context</dfn>, a [=string=]-or-null, set during creation.

Every {{Summarizer}} has a <dfn for="Summarizer">summary type</dfn>, an {{SummarizerType}}, set during creation.

Every {{Summarizer}} has a <dfn for="Summarizer">summary format</dfn>, an {{SummarizerFormat}}, set during creation.

Every {{Summarizer}} has a <dfn for="Summarizer">summary length</dfn>, an {{SummarizerLength}}, set during creation.

Every {{Summarizer}} has an <dfn for="Summarizer">expected input languages</dfn>, a <code>{{FrozenArray}}&lt;{{DOMString}}></code> or null, set during creation.

Every {{Summarizer}} has an <dfn for="Summarizer">expected context languages</dfn>, a <code>{{FrozenArray}}&lt;{{DOMString}}></code> or null, set during creation.

Every {{Summarizer}} has an <dfn for="Summarizer">output language</dfn>, a [=string=] or null, set during creation.

Every {{Summarizer}} has a <dfn for="Summarizer">input quota</dfn>, a number, set during creation.

<hr>

The <dfn attribute for="Summarizer">sharedContext</dfn> getter steps are to return [=this=]'s [=Summarizer/shared context=].

The <dfn attribute for="Summarizer">type</dfn> getter steps are to return [=this=]'s [=Summarizer/summary type=].

The <dfn attribute for="Summarizer">format</dfn> getter steps are to return [=this=]'s [=Summarizer/summary format=].

The <dfn attribute for="Summarizer">length</dfn> getter steps are to return [=this=]'s [=Summarizer/summary length=].

The <dfn attribute for="Summarizer">expectedInputLanguages</dfn> getter steps are to return [=this=]'s [=Summarizer/expected input languages=].

The <dfn attribute for="Summarizer">expectedContextLanguages</dfn> getter steps are to return [=this=]'s [=Summarizer/expected context languages=].

The <dfn attribute for="Summarizer">outputLanguage</dfn> getter steps are to return [=this=]'s [=Summarizer/output language=].

The <dfn attribute for="Summarizer">inputQuota</dfn> getter steps are to return [=this=]'s [=Summarizer/input quota=].

<hr>

<div algorithm>
  The <dfn method for="Summarizer">summarize(|input|, |options|)</dfn> method steps are:

  1. Let |context| be |options|["{{SummarizerSummarizeOptions/context}}"] if it [=map/exists=]; otherwise null.

  1. Let |operation| be an algorithm step which takes arguments |chunkProduced|, |done|, |error|, and |stopProducing|, and [=summarizes=] |input| given [=this=]'s [=Summarizer/shared context=], |context|, [=this=]'s [=Summarizer/summary type=], [=this=]'s [=Summarizer/summary format=], [=this=]'s [=Summarizer/summary length=], [=this=]'s [=Summarizer/output language=], [=this=]'s [=Summarizer/input quota=], |chunkProduced|, |done|, |error|, and |stopProducing|.

  1. Return the result of [=getting an aggregated AI model result=] given [=this=], |options|, and |operation|.
</div>

<div algorithm>
  The <dfn method for="Summarizer">summarizeStreaming(|input|, |options|)</dfn> method steps are:

  1. Let |context| be |options|["{{SummarizerSummarizeOptions/context}}"] if it [=map/exists=]; otherwise null.

  1. Let |operation| be an algorithm step which takes arguments |chunkProduced|, |done|, |error|, and |stopProducing|, and [=summarizes=] |input| given [=this=]'s [=Summarizer/shared context=], |context|, [=this=]'s [=Summarizer/summary type=], [=this=]'s [=Summarizer/summary format=], [=this=]'s [=Summarizer/summary length=], [=this=]'s [=Summarizer/output language=], [=this=]'s [=Summarizer/input quota=], |chunkProduced|, |done|, |error|, and |stopProducing|.

  1. Return the result of [=getting a streaming AI model result=] given [=this=], |options|, and |operation|.
</div>

<div algorithm>
  The <dfn method for="Summarizer">measureInputUsage(|input|, |options|)</dfn> method steps are:

  1. Let |context| be |options|["{{SummarizerSummarizeOptions/context}}"] if it [=map/exists=]; otherwise null.

  1. Let |measureUsage| be an algorithm step which takes argument |stopMeasuring|, and returns the result of [=measuring summarizer input usage=] given |input|, [=this=]'s [=Summarizer/shared context=], |context|, [=this=]'s [=Summarizer/summary type=], [=this=]'s [=Summarizer/summary format=], [=this=]'s [=Summarizer/summary length=], [=this=]'s [=Summarizer/output language=], and |stopMeasuring|.

  1. Return the result of [=measuring AI model input usage=] given [=this=], |options|, and |measureUsage|.
</div>

<h3 id="summarizer-summarization">Summarization</h3>

<h4 id="summarizer-algorithm">The algorithm</h4>

<div algorithm>
  To <dfn>summarize</dfn> given:

  * a [=string=] |input|,
  * a [=string=]-or-null |sharedContext|,
  * a [=string=]-or-null |context|,
  * an {{SummarizerType}} |type|,
  * an {{SummarizerFormat}} |format|,
  * an {{SummarizerLength}} |length|,
  * a [=string=]-or-null |outputLanguage|,
  * a number |inputQuota|,
  * an algorithm |chunkProduced| that takes a [=string=] and returns nothing,
  * an algorithm |done| that takes no arguments and returns nothing,
  * an algorithm |error| that takes [=error information=] and returns nothing, and
  * an algorithm |stopProducing| that takes no arguments and returns a boolean,

  perform the following steps:

  1. [=Assert=]: this algorithm is running [=in parallel=].

  1. Let |requested| be the result of [=measuring summarizer input usage=] given |input|, |sharedContext|, |context|, |type|, |format|, |length|, |outputLanguage|, and |stopProducing|.

  1. If |requested| is null, then return.

  1. If |requested| is an [=error information=], then:

    1. Perform |error| given |requested|.

    1. Return.

  1. [=Assert=]: |requested| is a number.

  1. If |requested| is greater than |inputQuota|, then:

    1. Let |errorInfo| be a [=quota exceeded error information=] with a [=quota exceeded error information/requested=] of |requested| and a [=quota exceeded error information/quota=] of |inputQuota|.

    1. Perform |error| given |errorInfo|.

    1. Return.

    <p class="note">In reality, we expect that implementations will check the input usage against the quota as part of the same call into the model as the summarization itself. The steps are only separated in the specification for ease of understanding.

  1. In an [=implementation-defined=] manner, subject to the following guidelines, begin the processs of summarizing |input| into a string.

     If they are non-null, |sharedContext| and |context| should be used to aid in the summarization by providing context on how the web developer wishes the input to be summarized.

     If |input| is the empty string, or otherwise consists of no summarizable content (e.g., only contains whitespace, or control characters), then the resulting summary should be the empty string. In such cases, |sharedContext|, |context|, |type|, |format|, |length|, and |outputLanguage| should be ignored.

     The summarization should conform to the guidance given by |type|, |format|, and |length|, in the definitions of each of their enumeration values.

     If |outputLanguage| is non-null, the summarization should be in that language. Otherwise, it should be in the language of |input| (which might not match that of |context| or |sharedContext|). If |input| contains multiple languages, or the language of |input| cannot be detected, then either the output language is [=implementation-defined=], or the implementation may treat this as an error, per the guidance in [[#summarizer-errors]].

  1. While true:

    1. Wait for the next chunk of summarization data to be produced, for the summarization process to finish, or for the result of calling |stopProducing| to become true.

    1. If such a chunk is successfully produced:

      1. Let it be represented as a [=string=] |chunk|.

      1. Perform |chunkProduced| given |chunk|.

    1. Otherwise, if the summarization process has finished:

      1. Perform |done|.

      1. [=iteration/Break=].

    1. Otherwise, if |stopProducing| returns true, then [=iteration/break=].

    1. Otherwise, if an error occurred during summarization:

      1. Let the error be represented as [=error information=] |errorInfo| according to the guidance in [[#summarizer-errors]].

      1. Perform |error| given |errorInfo|.

      1. [=iteration/Break=].
</div>

<h4 id="summarizer-usage">Usage</h4>

<div algorithm>
  To <dfn>measure summarizer input usage</dfn>, given:

  * a [=string=] |input|,
  * a [=string=]-or-null |sharedContext|,
  * a [=string=]-or-null |context|,
  * an {{SummarizerType}} |type|,
  * an {{SummarizerFormat}} |format|,
  * an {{SummarizerLength}} |length|,
  * a [=string=]-or-null |outputLanguage|, and
  * an algorithm |stopMeasuring| that takes no arguments and returns a boolean,

  perform the following steps:

  1. [=Assert=]: this algorithm is running [=in parallel=].

  1. Let |inputToModel| be the [=implementation-defined=] string that would be sent to the underlying model in order to [=summarize=] given |input|, |sharedContext|, |context|, |type|, |format|, |length|, and |outputLanguage|.

    <p class="note" id="note-input-to-model">This might be something similar to the concatenation of |input| and |context|, if all of the other options were loaded into the model during initialization, and so the input usage for those was already accounted for when computing the [=Summarizer/input quota=]. Or it might consist of more, if the options are sent along with every summarization call, or if there is a per-summarization wrapper prompt of some sort.

    If during this process |stopMeasuring| starts returning true, then return null.

    If an error occurs during this process, then return an appropriate [=DOMException error information=] according to the guidance in [[#summarizer-errors]].

  1. Return the amount of input usage needed to represent |inputToModel| when given to the underlying model. The exact calculation procedure is [=implementation-defined=], subject to the following constraints.

    The returned input usage must be nonnegative and finite. It must be 0, if there are no usage quotas for the summarization process (i.e., if the [=Summarizer/input quota=] is +∞). Otherwise, it must be positive and should be roughly proportional to the [=string/length=] of |inputToModel|.

    <p class="note" id="note-summarizer-input-usage">This might be the number of tokens needed to represent |input| in a <a href="https://arxiv.org/abs/2404.08335">language model tokenization scheme</a>, or it might be |input|'s [=string/length=]. It could also be some variation of these which also counts the usage of any prefixes or suffixes necessary to give to the model.

    If during this process |stopMeasuring| starts returning true, then instead return null.

    If an error occurs during this process, then instead return an appropriate [=DOMException error information=] according to the guidance in [[#summarizer-errors]].
</div>

<h4 id="summarizer-options">Options</h4>

The [=summarize=] algorithm's details are [=implementation-defined=], as they are expected to be powered by an AI model. However, it is intended to be controllable by the web developer through the {{SummarizerType}}, {{SummarizerFormat}}, and {{SummarizerLength}} enumerations.

This section gives normative guidance on how the implementation of [=summarize=] should use each enumeration value to guide the summarization process.

<table class="data enum-table">
  <caption>{{SummarizerType}} values</caption>
  <thead>
    <tr>
      <th>Value
      <th>Meaning
  <tbody>
    <tr>
      <th>"<dfn enum-value for="SummarizerType">tl;dr</dfn>"
      <td>
        <p>The summary should be short and to the point, providing a quick overview of the input, suitable for a busy reader.
    <tr>
      <th>"<dfn enum-value for="SummarizerType">teaser</dfn>"
      <td>
        <p>The summary should focus on the most interesting or intriguing parts of the input, designed to draw the reader in to read more.
    <tr>
      <th>"<dfn enum-value for="SummarizerType">key-points</dfn>"
      <td>
        <p>The summary should extract the most important points from the input, presented as a bulleted list.
    <tr>
      <th>"<dfn enum-value for="SummarizerType">headline</dfn>"
      <td>
        <p>The summary should effectively contain the main point of the input in a single sentence, in the format of an article headline.
</table>

<table class="data enum-table">
  <caption>{{SummarizerLength}} values</caption>
  <thead>
    <tr>
      <th>Value
      <th>Meaning
  <tbody>
    <tr>
      <th>"<dfn enum-value for="SummarizerLength">short</dfn>"
      <td>
        <p>The guidance is dependent on the value of {{SummarizerType}}:

        <dl class="switch">
          : "{{SummarizerType/tl;dr}}"
          : "{{SummarizerType/teaser}}"
          :: The summary should fit within 1 sentence.
          : "{{SummarizerType/key-points}}"
          :: The summary should consist of no more than 3 bullet points.
          : "{{SummarizerType/headline}}"
          :: The summary should use no more than 12 words.
        </dl>
    <tr>
      <th>"<dfn enum-value for="SummarizerLength">medium</dfn>"
      <td>
        <p>The guidance is dependent on the value of {{SummarizerType}}:

        <dl class="switch">
          : "{{SummarizerType/tl;dr}}"
          : "{{SummarizerType/teaser}}"
          :: The summary should fit within 1 short paragraph.
          : "{{SummarizerType/key-points}}"
          :: The summary should consist of no more than 5 bullet points.
          : "{{SummarizerType/headline}}"
          :: The summary should use no more than 17 words.
        </dl>
    <tr>
      <th>"<dfn enum-value for="SummarizerLength">long</dfn>"
      <td>
        <p>The guidance is dependent on the value of {{SummarizerType}}:

        <dl class="switch">
          : "{{SummarizerType/tl;dr}}"
          : "{{SummarizerType/teaser}}"
          :: The summary should fit within 1 paragraph.
          : "{{SummarizerType/key-points}}"
          :: The summary should consist of no more than 7 bullet points.
          : "{{SummarizerType/headline}}"
          :: The summary should use no more than 22 words.
        </dl>
</table>

<p class="note">As with all "<span class="allow-2119">should</span>"-level guidance, user agents might not conform perfectly to these. Especially in the case of counting words, it's expected that language models might not conform perfectly.

<table class="data enum-table">
  <caption>{{SummarizerFormat}} values</caption>
  <thead>
    <tr>
      <th>Value
      <th>Meaning
  <tbody>
    <tr>
      <th>"<dfn enum-value for="SummarizerFormat">plain-text</dfn>"
      <td>
        <p>The summary should not contain any formatting or markup language.
    <tr>
      <th>"<dfn enum-value for="SummarizerFormat">markdown</dfn>"
      <td>
        <p>The summary should be formatted using the Markdown markup language, ideally as valid CommonMark. [[!COMMONMARK]]
</table>

<h4 id="summarizer-errors">Errors</h4>

When summarization fails, the following possible reasons may be surfaced to the web developer. This table lists the possible {{DOMException}} [=DOMException/names=] and the cases in which an implementation should use them:

<table class="data">
  <thead>
    <tr>
      <th>{{DOMException}} [=DOMException/name=]
      <th>Scenarios
  <tbody>
    <tr>
      <td>"{{NotAllowedError}}"
      <td>
        <p>Summarization is disabled by user choice or user agent policy.
    <tr>
      <td>"{{NotReadableError}}"
      <td>
        <p>The summarization output was filtered by the user agent, e.g., because it was detected to be harmful, inaccurate, or nonsensical.
    <tr>
      <td>"{{NotSupportedError}}"
      <td>
        <p>The input to be summarized, or the context to be provided, was in a language that the user agent does not support, or was not provided properly in the call to {{Summarizer/create()}}.

        <p>The summarization output ended up being in a language that the user agent does not support (e.g., because the user agent has not performed sufficient quality control tests on that output language), or was not provided properly in the call to {{Summarizer/create()}}.

        <p>The {{SummarizerCreateCoreOptions/outputLanguage}} option was not set, and the language of the input text could not be determined, so the user agent did not have a good output language default available.
    <tr>
      <td>"{{UnknownError}}"
      <td>
        <p>All other scenarios, or if the user agent would prefer not to disclose the failure reason.
</table>

<p class="note">This table does not give the complete list of exceptions that can be surfaced by the summarizer API. It only contains those which can come from certain [=implementation-defined=] steps.

<h2 id="writer-api">The writer API</h2>

Just IDL for now; full spec coming!

<xmp class="idl">
[Exposed=(Window,Worker), SecureContext]
interface Writer {
  static Promise<Writer> create(optional WriterCreateOptions options = {});
  static Promise<Availability> availability(optional WriterCreateCoreOptions options = {});

  Promise<DOMString> write(
    DOMString input,
    optional WriterWriteOptions options = {}
  );
  ReadableStream writeStreaming(
    DOMString input,
    optional WriterWriteOptions options = {}
  );

  readonly attribute DOMString sharedContext;
  readonly attribute WriterTone tone;
  readonly attribute WriterFormat format;
  readonly attribute WriterLength length;

  readonly attribute FrozenArray<DOMString>? expectedInputLanguages;
  readonly attribute FrozenArray<DOMString>? expectedContextLanguages;
  readonly attribute DOMString? outputLanguage;

  Promise<double> measureInputUsage(
    DOMString input,
    optional WriterWriteOptions options = {}
  );
  readonly attribute unrestricted double inputQuota;
};
Writer includes DestroyableModel;

dictionary WriterCreateCoreOptions {
  WriterTone tone = "neutral";
  WriterFormat format = "markdown";
  WriterLength length = "short";

  sequence<DOMString> expectedInputLanguages;
  sequence<DOMString> expectedContextLanguages;
  DOMString outputLanguage;
};

dictionary WriterCreateOptions : WriterCreateCoreOptions {
  AbortSignal signal;
  CreateMonitorCallback monitor;

  DOMString sharedContext;
};

dictionary WriterWriteOptions {
  DOMString context;
  AbortSignal signal;
};

enum WriterTone { "formal", "neutral", "casual" };
enum WriterFormat { "plain-text", "markdown" };
enum WriterLength { "short", "medium", "long" };
</xmp>

<h2 id="rewriter-api">The rewriter API</h2>

Just IDL for now; full spec coming!

<xmp class="idl">
[Exposed=(Window,Worker), SecureContext]
interface Rewriter {
  static Promise<Rewriter> create(optional RewriterCreateOptions options = {});
  static Promise<Availability> availability(optional RewriterCreateCoreOptions options = {});

  Promise<DOMString> rewrite(
    DOMString input,
    optional RewriterRewriteOptions options = {}
  );
  ReadableStream rewriteStreaming(
    DOMString input,
    optional RewriterRewriteOptions options = {}
  );

  readonly attribute DOMString sharedContext;
  readonly attribute RewriterTone tone;
  readonly attribute RewriterFormat format;
  readonly attribute RewriterLength length;

  readonly attribute FrozenArray<DOMString>? expectedInputLanguages;
  readonly attribute FrozenArray<DOMString>? expectedContextLanguages;
  readonly attribute DOMString? outputLanguage;

  Promise<double> measureInputUsage(
    DOMString input,
    optional RewriterRewriteOptions options = {}
  );
  readonly attribute unrestricted double inputQuota;
};
Rewriter includes DestroyableModel;

dictionary RewriterCreateCoreOptions {
  RewriterTone tone = "as-is";
  RewriterFormat format = "as-is";
  RewriterLength length = "as-is";

  sequence<DOMString> expectedInputLanguages;
  sequence<DOMString> expectedContextLanguages;
  DOMString outputLanguage;
};

dictionary RewriterCreateOptions : RewriterCreateCoreOptions {
  AbortSignal signal;
  CreateMonitorCallback monitor;

  DOMString sharedContext;
};

dictionary RewriterRewriteOptions {
  DOMString context;
  AbortSignal signal;
};

enum RewriterTone { "as-is", "more-formal", "more-casual" };
enum RewriterFormat { "as-is", "plain-text", "markdown" };
enum RewriterLength { "as-is", "shorter", "longer" };
</xmp>

<h2 id="supporting">Shared infrastructure</h2>

<h3 id="supporting-creation">Creation</h3>

<div algorithm>
  To <dfn export>create an AI model object</dfn> given:

  * an [=ordered map=] |options|,
  * an algorithm |validateAndCanonicalizeOptions| taking an [=ordered map=] and returning nothing,
  * an algorithm |getAvailability| taking an [=ordered map=] and returning an {{Availability}} or null,
  * an algorithm |startDownload| taking an [=ordered map=] and returning a boolean,
  * an algorithm |initialize| taking an [=ordered map=] and returning an error information or null, and
  * an algorithm |create| taking a [=ECMAScript/realm=] and an [=ordered map=] and returning a Web IDL object representing the model,

  perform the following steps:

  1. Let |realm| be the [=current realm=].

  1. If |realm|'s [=realm/global object=] is a {{Window}} whose [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. If |options|["`signal`"] [=map/exists=] and is [=AbortSignal/aborted=], then return [=a promise rejected with=] |options|["`signal`"]'s [=AbortSignal/abort reason=].

  1. Perform |validateAndCanonicalizeOptions| given |options|. If this throws an exception |e|, catch it, and return [=a promise rejected with=] |e|.

     <p class="note">This can mutate |options|.

  1. Let |fireProgressEvent| be an algorithm taking two arguments that does nothing.

  1. If |options|["`monitor`"] [=map/exists=], then:

    1. Let |monitor| be a [=new=] {{CreateMonitor}} created in |realm|.

    1. [=Invoke=] |options|["`monitor`"] with « |monitor| » and "`rethrow`".

      If this throws an exception |e|, catch it, and return [=a promise rejected with=] |e|.

    1. Set |fireProgressEvent| to an algorithm taking argument |loaded|, which performs the following steps:

      1. [=Assert=]: this algorithm is running [=in parallel=].

      1. [=Queue a global task=] on the [=AI task source=] given |realm|'s [=realm/global object=] to perform the following steps:

        1. [=Fire an event=] named {{CreateMonitor/downloadprogress}} at |monitor|, using {{ProgressEvent}}, with the {{ProgressEvent/loaded}} attribute initialized to |loaded|, the {{ProgressEvent/total}} attribute initialized to 1, and the {{ProgressEvent/lengthComputable}} attribute initialized to true.

          <p class="advisement">This assumes <a href="https://github.com/whatwg/xhr/pull/394">whatwg/xhr#394</a> is merged so that passing non-integer values for {{ProgressEvent/loaded}} works as expected.</p>

  1. Let |abortedDuringDownload| be false.

    <p class="note">This variable will be written to from the [=event loop=], but read from [=in parallel=].

  1. If |options|["`signal`"] [=map/exists=], then [=AbortSignal/add|add the following abort steps=] to |options|["`signal`"]:

    1. Set |abortedDuringDownload| to true.

  1. Let |promise| be [=a new promise=] created in |realm|.

  1. [=In parallel=]:

    1. Let |availability| be the result of performing |getAvailability| given |options|.

       <p class="note">This can mutate |options|.

    1. Switch on |availability|:

    <dl class="switch">
      : null
      ::
        1. [=Reject=] |promise| with an "{{UnknownError}}" {{DOMException}}.

        1. Abort these steps.

      : "{{Availability/unavailable}}"
      ::
        1. [=Reject=] |promise| with a "{{NotSupportedError}}" {{DOMException}}.

        1. Abort these steps.

      : "{{Availability/available}}"
      ::
        1. [=Initialize and return an AI model object=] given |promise|, |options|, |fireProgressEvent|, |initialize|, and |create|.

      : "{{Availability/downloading}}"
      : "{{Availability/downloadable}}"
      ::
        1. If |availability| is "{{Availability/downloadable}}", then let |startDownloadResult| be the result of performing |startDownload| given |options|.

        1. If |startDownloadResult| is false, then:

          1. [=Queue a global task=] on the [=AI task source=] given |realm|'s [=realm/global object=] to [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.

          1. Abort these steps.

        1. Run the following steps, but [=abort when=] |abortedDuringDownload| becomes true:

          1. Wait for the total number of bytes to be downloaded to become determined, and let that number be |totalBytes|.

             This number must be equal to the number of bytes that the user agent needs to download at the present time, not including any that have already been downloaded.

             <div class="note">
              <p>For example, if another tab has started the download and it is 90% finished, and the user agent is planning to share the model across all tabs, then |totalBytes| will be 10% of the size of the model, not 100% of the size of the model.

              <p>This prevents the web developer-perceived progress from suddenly jumping from 0% to 90%, and then taking a long time to go from 90% to 100%. It also provides some protection against the (admittedly not very powerful) fingerprinting vector of measuring the current download progress across multiple sites.
             </div>

          1. Let |lastProgressFraction| be 0.

          1. Let |lastProgressTime| be the [=monotonic clock=]'s [=monotonic clock/unsafe current time=].

          1. Perform |fireProgressEvent| given 0.

          1. While true:

            1. If downloading has failed, then:

              1. [=Queue a global task=] on the [=AI task source=] given |realm|'s [=realm/global object=] to [=reject=] |promise| with a "{{NetworkError}}" {{DOMException}}.

              1. Abort these steps.

            1. Let |bytesSoFar| be the number of bytes downloaded so far.

            1. [=Assert=]: |bytesSoFar| is greater than or equal to 0, and less than or equal to |totalBytes|.

            1. If the [=monotonic clock=]'s [=monotonic clock/unsafe current time=] minus |lastProgressTime| is greater than 50 ms, or |bytesSoFar| equals |totalBytes|, then:

              1. Let |rawProgressFraction| be |bytesSoFar| divided by |totalBytes|.

              1. Let |progressFraction| be [$floor$](|rawProgressFraction| &times; 65,536) &divide; 65,536.

                  <div class="note">
                  <p>We use a fraction, instead of firing a progress event with the number of bytes downloaded, to avoid giving precise information about the size of the model or other material being downloaded.</p>

                  <p>|progressFraction| is calculated from |rawProgressFraction| to give a precision of one part in 2<sup>16</sup>. This ensures that over most internet speeds and with most model sizes, the {{ProgressEvent/loaded}} value will be different from the previous one that was fired ~50 milliseconds ago.</p>

                  <details>
                    <summary>Full calculation</summary>

                    <p>Assume a 5 GiB download size, and a 20 Mbps download speed (chosen as a number on the lower range from [this source](https://worldpopulationreview.com/country-rankings/internet-speeds-by-country)). Then, downloading 5 GiB will take:</p>

                    <math style="display:block math">
                      <mtable>
                        <mtr>
                          <mtd></mtd>
                          <mtd style="text-align: left">
                            <mn>5</mn>
                            <mtext>&nbsp;GiB</mtext>

                            <mo>×</mo>
                            <mfrac>
                              <mrow>
                                <msup>
                                  <mn>2</mn>
                                  <mn>30</mn>
                                </msup>
                                <mtext>&nbsp;bytes</mtext>
                              </mrow>
                              <mtext>GiB</mtext>
                            </mfrac>

                            <mo>×</mo>
                            <mfrac>
                              <mrow>
                                <mn>8</mn>
                                <mtext>&nbsp;bits</mtext>
                              </mrow>
                              <mtext>bytes</mtext>
                            </mfrac>

                            <mo>÷</mo>
                            <mfrac>
                              <mrow>
                                <mn>20</mn>
                                <mo>×</mo>
                                <msup>
                                  <mn>10</mn>
                                  <mn>6</mn>
                                </msup>
                                <mtext>&nbsp;bits</mtext>
                              </mrow>
                              <mtext>s</mtext>
                            </mfrac>

                            <mo>×</mo>
                            <mfrac>
                              <mrow>
                                <mn>1000</mn>
                                <mtext>&nbsp;ms</mtext>
                              </mrow>
                              <mtext>s</mtext>
                            </mfrac>

                            <mo>÷</mo>
                            <mfrac>
                              <mrow>
                                <mn>50</mn>
                                <mtext>&nbsp;ms</mtext>
                              </mrow>
                              <mtext>interval</mtext>
                            </mfrac>
                          </mtd>
                        </mtr>

                        <mtr>
                          <mtd>
                            <mo>=</mo>
                          </mtd>
                          <mtd style="text-align: left">
                            <mn>49,950</mn>
                            <mtext>&nbsp;intervals</mtext>
                          </mtd>
                        </mtr>
                      </mtable>
                    </math>

                    Rounding up to the nearest power of two gives a conservative estimate of 65,536 fifty millisecond intervals, so we want to give progress to 1 part in 2<sup>16</sup>.
                  </details>
                </div>

              1. If |progressFraction| is not equal to |lastProgressFraction|, then perform |fireProgressEvent| given |progressFraction|.

              1. If |bytesSoFar| equals |totalBytes|, then [=iteration/break=].

                <p class="note">Since this is the only non-failure exit condition for the loop, we will never miss firing a {{CreateMonitor/downloadprogress}} event for the 100% mark.</p>

              1. Set |lastProgressFraction| to |progressFraction|.

              1. Set |lastProgressTime| to the [=monotonic clock=]'s [=monotonic clock/unsafe current time=].

        1. [=If aborted=], then:

          1. [=Queue a global task=] on the [=AI task source=] given |realm|'s [=realm/global object=] to perform the following steps:

            1. [=Assert=]: |options|["`signal`"] is [=AbortSignal/aborted=].

            1. [=Reject=] |promise| with |options|["`signal`"]'s [=AbortSignal/abort reason=].

          1. Abort these steps.

        1. [=Initialize and return an AI model object=] given |promise|, |options|, a no-op algorithm, |initialize|, and |create|.
    </dl>

  1. Return |promise|.
</div>

<div algorithm>
  To <dfn>initialize and return an AI model object</dfn> given a {{Promise}} |promise|, an [=ordered map=] |options|, and algorithms |fireProgressEvent|, |initialize|, and |create|:

  1. [=Assert=]: these steps are running [=in parallel=].

  1. Perform |fireProgressEvent| given 0.

  1. Perform |fireProgressEvent| given 1.

  1. Let |result| be the result of performing |initialize| given |options|.

  1. [=Queue a global task=] on the [=AI task source=] given |promise|'s [=relevant global object=] to perform the following steps:

    1. If |options|["`signal`"] [=map/exists=] and is [=AbortSignal/aborted=], then:

      1. [=Reject=] |promise| with |options|["`signal`"]'s [=AbortSignal/abort reason=].

      1. Abort these steps.

      <p class="note">This check is necessary in case any code running on the [=agent/event loop=] caused the {{AbortSignal}} to become [=AbortSignal/aborted=] before this [=task=] ran.

    1. If |result| is an [=error information=], then:

      1. [=Reject=] |promise| with the result of [=converting error information into an exception object=] given |result|.

      1. Abort these steps.

    1. Let |model| be the result of performing |create| given |promise|'s [=relevant global object=] and |options|.

    1. [=Assert=]: |model| [=implements=] an [=interface=] that [=interface/includes=] {{DestroyableModel}}.

    1. [=Initialize as a destroyable=] |model|.

    1. If |options|["`signal`"] [=map/exists=], then [=AbortSignal/add|add the following abort steps=] to |options|["`signal`"]:

      1. [=DestroyableModel/Destroy=] |model| given |options|["`signal`"]'s [=AbortSignal/abort reason=].

    1. [=Resolve=] |promise| with |model|.
</div>

<h3 id="supporting-results">Obtaining results and usage</h3>

<div algorithm>
  To <dfn export>get an aggregated AI model result</dfn> given an {{DestroyableModel}} |modelObject|, an [=ordered map=] |options|, and an algorithm |operation|:

  1. If |modelObject|'s [=relevant global object=] is a {{Window}} whose [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |signals| be « |modelObject|'s [=DestroyableModel/destruction abort controller=]'s [=AbortController/signal=] ».

  1. If |options|["`signal`"] [=map/exists=], then [=set/append=] it to |signals|.

  1. Let |compositeSignal| be the result of [=creating a dependent abort signal=] given |signals| using {{AbortSignal}} and |modelObject|'s [=relevant realm=].

  1. If |compositeSignal| is [=AbortSignal/aborted=], then return [=a promise rejected with=] |compositeSignal|'s [=AbortSignal/abort reason=].

  1. Let |abortedDuringOperation| be false.

    <p class="note">This variable will be written to from the [=event loop=], but read from [=in parallel=].

  1. [=AbortSignal/add|Add the following abort steps=] to |compositeSignal|:

    1. Set |abortedDuringOperation| to true.

  1. Let |promise| be [=a new promise=] created in |modelObject|'s [=relevant realm=].

  1. [=In parallel=]:

    1. Let |result| be the empty string.

    1. Let |chunkProduced| be the following steps given a [=string=] |chunk|:

      1. [=Queue a global task=] on the [=AI task source=] given |modelObject|'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=reject=] |promise| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, append |chunk| to |result|.

    1. Let |done| be the following steps:

      1. [=Queue a global task=] on the [=AI task source=] given |modelObject|'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=reject=] |promise| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, [=resolve=] |promise| with |result|.

    1. Let |error| be the following steps given [=error information=] |errorInfo|:

      1. [=Queue a global task=] on the [=AI task source=] given |modelObject|'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=reject=] |promise| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, [=reject=] |promise| with the result [=converting error information into an exception object=] given |errorInfo|.

    1. Let |stopProducing| be the following steps:

      1. Return |abortedDuringOperation|.

    1. Perform |operation| given |chunkProduced|, |done|, |error|, and |stopProducing|.

  1. Return |promise|.
</div>

<div algorithm>
  To <dfn export>get a streaming AI model result</dfn> given an {{DestroyableModel}} |modelObject|, an [=ordered map=] |options|, and an algorithm |operation|:

  1. If |modelObject|'s [=relevant global object=] is a {{Window}} whose [=associated Document=] is not [=Document/fully active=], then throw an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |signals| be « |modelObject|'s [=DestroyableModel/destruction abort controller=]'s [=AbortController/signal=] ».

  1. If |options|["{{SummarizerSummarizeOptions/signal}}"] [=map/exists=], then [=set/append=] it to |signals|.

  1. Let |compositeSignal| be the result of [=creating a dependent abort signal=] given |signals| using {{AbortSignal}} and |modelObject|'s [=relevant realm=].

  1. If |compositeSignal| is [=AbortSignal/aborted=], then return [=a promise rejected with=] |compositeSignal|'s [=AbortSignal/abort reason=].

  1. Let |abortedDuringOperation| be false.

    <p class="note">This variable will be written to from the [=event loop=], but read from [=in parallel=].

  1. [=AbortSignal/add|Add the following abort steps=] to |compositeSignal|:

    1. Set |abortedDuringOperation| to true.

  1. Let |stream| be a [=new=] {{ReadableStream}} created in [=this=]'s [=relevant realm=].

  1. Let |canceledDuringOperation| be false.

    <p class="note">This variable tracks web developer [=ReadableStream/cancel|stream cancelations=] via {{ReadableStream/cancel()|stream.cancel()}}, which are not surfaced as errors.  It will be written to from the [=event loop=], but sometimes read from [=in parallel=].

  1. [=ReadableStream/Set up=] |stream| with <i>[=ReadableStream/set up/cancelAlgorithm=]</i> set to the following steps (ignoring the <var ignore>reason</var> argument):

    1. Set |canceledDuringOperation| to true.

  1. [=In parallel=]:

    1. Let |chunkProduced| be the following steps given a [=string=] |chunk|:

      1. [=Queue a global task=] on the [=AI task source=] given [=this=]'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=ReadableStream/error=] |stream| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, [=ReadableStream/enqueue=] |chunk| into |stream|.

    1. Let |done| be the following steps:

      1. [=Queue a global task=] on the [=AI task source=] given [=this=]'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=ReadableStream/error=] |stream| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, [=ReadableStream/close=] |stream|.

    1. Let |error| be the following steps given [=error information=] |errorInfo|:

      1. [=Queue a global task=] on the [=AI task source=] given [=this=]'s [=relevant global object=] to perform the following steps:

        1. If |abortedDuringOperation| is true, then [=ReadableStream/error=] |stream| with |compositeSignal|'s [=AbortSignal/abort reason=].

        1. Otherwise, [=ReadableStream/error=] |stream| with the result of [=converting error information into an exception object=] given |errorInfo|.

    1. Let |stopProducing| be the following steps:

      1. If either |abortedDuringOperation| or |canceledDuringOperation| are true, then return true.

      1. Return false.

    1. Perform |operation| given |chunkProduced|, |done|, |error|, and |stopProducing|.

  1. Return |stream|.
</div>

<div algorithm>
  To <dfn export>measure AI model input usage</dfn> given an {{DestroyableModel}} |modelObject|, an [=ordered map=] |options|, and an algorithm |measure|:

  1. If |modelObject|'s [=relevant global object=] is a {{Window}} whose [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. Let |signals| be « |modelObject|'s [=DestroyableModel/destruction abort controller=]'s [=AbortController/signal=] ».

  1. If |options|["`signal`"] [=map/exists=], then [=set/append=] it to |signals|.

  1. Let |compositeSignal| be the result of [=creating a dependent abort signal=] given |signals| using {{AbortSignal}} and |modelObject|'s [=relevant realm=].

  1. If |compositeSignal| is [=AbortSignal/aborted=], then return [=a promise rejected with=] |compositeSignal|'s [=AbortSignal/abort reason=].

  1. Let |abortedDuringMeasurement| be false.

    <p class="note">This variable will be written to from the [=event loop=], but read from [=in parallel=].

  1. [=AbortSignal/add|Add the following abort steps=] to |compositeSignal|:

    1. Set |abortedDuringMeasurement| to true.

  1. Let |promise| be [=a new promise=] created in |modelObject|'s [=relevant realm=].

  1. [=In parallel=]:

    1. Let |stopMeasuring| be the following steps:

      1. Return |abortedDuringMeasurement|.

    1. Let |result| be the result of performing |measure| given |stopMeasuring|.

    1. [=Queue a global task=] on the [=AI task source=] given |modelObject|'s [=relevant global object=] to perform the following steps:

      1. If |abortedDuringMeasurement| is true, then [=reject=] |promise| with |compositeSignal|'s [=AbortSignal/abort reason=].

      1. Otherwise, if |result| is an [=error information=], then [=reject=] |promise| with the result [=converting error information into an exception object=] given |result|.

      1. Otherwise,

        1. [=Assert=]: |result| is a number. (It is not null, since in that case |abortedDuringMeasurement| would have been true.)

        1. [=Resolve=] |promise| with |result|.

  1. Return |promise|.
</div>

<h3 id="supporting-language-tags">Language tags</h3>

<div algorithm>
  To <dfn export>validate and canonicalize language tags</dfn> given a [=ordered map=] |options| and a [=string=] |key|, perform the following steps. They mutate |options| in place to canonicalize and deduplicate language tags found in |options|[|key|], and throw a {{TypeError}} if any are invalid.

  1. [=Assert=]: |options|[|key|] [=map/exists=].

  1. If |options|[|key|] is a [=string=], then set |options|[|key|] to the result of [=validating and canonicalizing a single language tag=] given |options|[|key|].

  1. Otherwise:

    1. [=Assert=]: |options|[|key|] either does not [=map/exist=], or it is a [=list=] of [=strings=].

    1. Let |languageTags| be an empty [=ordered set=].

    1. If |options|[|key|] [=map/exists=], then [=list/for each=] |languageTag| of |options|[|key|]:

      1. If [$IsStructurallyValidLanguageTag$](|languageTag|) is false, then throw a {{TypeError}}.

      1. [=set/Append=] the result of [=validating and canonicalizing a single language tag=] to |languageTags|.

    1. Set |options|[|key|] to |languageTags|.
</div>

<div algorithm>
  To <dfn lt="validate and canonicalize a single language tag|validating and canonicalizing a single language tag">validate and canonicalize a single language tag</dfn> given a [=string=] |potentialLanguageTag|:

  1. If [$IsStructurallyValidLanguageTag$](|potentialLanguageTag|) is false, then throw a {{TypeError}}.

  1. Return [$CanonicalizeUnicodeLocaleId$](|potentialLanguageTag|).
</div>

<div algorithm>
  To <dfn export>get language availabilities</dfn> given a description |purpose| of the purpose for which we're checking language availability:

  1. Let |availabilities| be «[ "{{Availability/available}}" → an empty [=set=], "{{Availability/downloading}}" → an empty [=set=], "{{Availability/downloadable}}" → an empty [=set=] ]».

  1. [=list/For each=] human language |languageTag|, represented as a [=Unicode canonicalized locale identifier=], for which the user agent supports |purpose|, without performing any downloading operations:

    1. [=set/Append=] |languageTag| to |availabilities|["{{Availability/available}}"].

  1. [=list/For each=] human language |languageTag|, represented as a [=Unicode canonicalized locale identifier=], for which the user agent is currently downloading material (e.g., an AI model or fine-tuning) to support |purpose|:

    1. [=set/Append=] |languageTag| to |availabilities|["{{Availability/downloading}}"].

  1. [=list/For each=] human language |languageTag|, represented as a [=Unicode canonicalized locale identifier=], for which the user agent believes it can support |purpose|, but only after performing a not-currently-ongoing download (e.g., of an AI model or fine-tuning):

    1. [=set/Append=] |languageTag| to |availabilities|["{{Availability/downloadable}}"].

  1. [=Assert=]: |availabilities|["{{Availability/available}}"], |availabilities|["{{Availability/downloading}}"], and |availabilities|["{{Availability/downloadable}}"] are disjoint.

  1. If the [=set/union=] of |availabilities|["{{Availability/available}}"], |availabilities|["{{Availability/downloading}}"], and |availabilities|["{{Availability/downloadable}}"] does not meet the [=language tag set completeness rules=], then:

    1. Let |missingLanguageTags| be the [=set=] of missing language tags necessary to meet the [=language tag set completeness rules=].

    1. [=set/For each=] |languageTag| of |missingLanguageTags|:

      1. <span id="language-tag-completeness-implementation-defined"></span> [=set/Append=] |languageTag| to one of the three sets. Which of the sets to append to is [=implementation-defined=], and should be guided by considerations similar to that of [$LookupMatchingLocaleByBestFit$] in terms of keeping "best fallback languages" together.

    1. Return |availabilities|.
</div>

<div algorithm>
  The <dfn>language tag set completeness rules</dfn> state that for every [=set/item=] |languageTag|, if |languageTag| has more than one subtag, then the set must also contain a less narrow language tag with the same language subtag and a strict subset of the same following subtags (i.e., omitting one or more).

  <p class="note">This definition is intended to align with that of [=[[AvailableLocales]]=] in <cite>ECMAScript Internationalization API Specification</cite>. [[ECMA-402]]

  <div class="example" id="example-subtags-intro">
    This means that if an implementation supports summarization of "`de-DE`" input text, it will also count as supporting "`de`" input text.

    The converse direction is supported not by the [=language tag set completeness rules=], but instead by the use of [$LookupMatchingLocaleByBestFit$], which ensures that if an implementation supports summarizing "`de`" input text, it also counts as supporting summarization of "`de-CH`", "`de-Latn-CH`", etc.
  </div>
</div>

<h3 id="supporting-availability">Availability</h3>

<div algorithm>
  To <dfn export>compute AI model availability</dfn> given |options|, an algorithm |validate|, and an algorithm |compute|:

  1. Let |global| be the [=current global object=].

  1. If |global| is a {{Window}} whose [=associated Document=] is not [=Document/fully active=], then return [=a promise rejected with=] an "{{InvalidStateError}}" {{DOMException}}.

  1. Perform |validate| given |options|.

  1. Let |promise| be [=a new promise=] created in the [=current realm=].

  1. [=In parallel=]:

    1. Let |availability| be the result of |compute| given |options|.

    1. [=Queue a global task=] on the [=AI task source=] given |global| to perform the following steps:

      1. If |availability| is null, then [=reject=] |promise| with an "{{UnknownError}}" {{DOMException}}.

      1. Otherwise, [=resolve=] |promise| with |availability|.
</div>

<div algorithm>
  The <dfn export for="Availability">minimum availability</dfn> given a [=list=] of {{Availability}}-or-null values |availabilities| is:

  1. If |availabilities| [=list/contains=] null, then return null.

  1. If |availabilities| [=list/contains=] "{{Availability/unavailable}}", then return "{{Availability/unavailable}}".

  1. If |availabilities| [=list/contains=] "{{Availability/downloading}}", then return "{{Availability/downloading}}".

  1. If |availabilities| [=list/contains=] "{{Availability/downloadable}}", then return "{{Availability/downloadable}}".

  1. Return "{{Availability/available}}".
</div>

<h3 id="supporting-errors">Errors</h3>

An <dfn export>error information</dfn> is used to communicate error information from [=in parallel=] to the [=event loop=]. It is either a [=quota exceeded error information=] or a [=DOMException error information=].

A <dfn export>DOMException error information</dfn> is a [=struct=] with the following [=struct/items=]:

: <dfn export for="DOMException error information">name</dfn>
:: a [=string=] that will be used for the {{DOMException}}'s [=DOMException/name=].
: <dfn export for="DOMException error information">details</dfn>
:: other information necessary to create a useful {{DOMException}} for the web developer. (Typically, just an exception message.)

A <dfn export>quota exceeded error information</dfn> is a [=struct=] with the following [=struct/items=]:

: <dfn export for="quota exceeded error information">requested</dfn>
:: a number that will be used for the {{QuotaExceededError}}'s [=QuotaExceededError/requested=].
: <dfn export for="quota exceeded error information">quota</dfn>
:: a number that will be used for the {{QuotaExceededError}}'s [=QuotaExceededError/quota=].

<p class="advisement">The parts of this specification related to quota exceeded errors assume that <a href="https://github.com/whatwg/webidl/pull/1465">whatwg/webidl#1465</a> will be merged.

<div algorithm>
  To <dfn export>convert error information into an exception object</dfn>, given an [=error information=] |errorInfo|:

  1. If |errorInfo| is a [=DOMException error information=], then return a new {{DOMException}} with name given by |errorInfo|'s [=DOMException error information/name=], using |errorInfo|'s [=DOMException error information/details=] to populate the message appropriately.

  1. Otherwise:

    1. [=Assert=]: |error| is a [=quota exceeded error information=].

    1. Return a new {{QuotaExceededError}} whose [=QuotaExceededError/requested=] is |error|'s [=quota exceeded error information/requested=] and [=QuotaExceededError/quota=] is |error|'s [=quota exceeded error information/quota=].
</div>

<h3 id="supporting-task-source">Task source</h3>

[=Tasks=] queued by this specification use the <dfn export>AI task source</dfn>.
